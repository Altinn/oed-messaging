//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace Altinn.Dd.Correspondence.Infrastructure
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AltinnCorrespondenceClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public AltinnCorrespondenceClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://platform.tt02.altinn.no";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Initialize a new Attachment to be shared in correspondences
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Only required if the attachment is to be shared, otherwise this is done as part of the Initialize Correspondence operation
        /// </remarks>
        /// <returns>Returns the attachment id</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Guid> AttachmentPOSTAsync(InitializeAttachmentExt body)
        {
            return AttachmentPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initialize a new Attachment to be shared in correspondences
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Only required if the attachment is to be shared, otherwise this is done as part of the Initialize Correspondence operation
        /// </remarks>
        /// <returns>Returns the attachment id</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> AttachmentPOSTAsync(InitializeAttachmentExt body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment"
                    urlBuilder_.Append("correspondence/api/v1/attachment");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>2010: Filename is missing</li>\r\n  <li>2011: Filename is too long</li>\r\n  <li>2012: Filename contains invalid characters</li>\r\n  <li>2013: Filetype not allowed</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register </li>\r\n  <li>4009: Resource type is not supported. Resource must be of type GenericAccessResource or CorrespondenceService. </li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Upload attachment data to Altinn Correspondence blob storage
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AttachmentOverviewExt> UploadAsync(System.Guid attachmentId)
        {
            return UploadAsync(attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Upload attachment data to Altinn Correspondence blob storage
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AttachmentOverviewExt> UploadAsync(System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment/{attachmentId}/upload"
                    urlBuilder_.Append("correspondence/api/v1/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/upload");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentOverviewExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>2003: Cannot upload attachment to a correspondence that has been created</li>\r\n  <li>2004: File must have content and has a max file size of 250 MB</li>\r\n  <li>2005: File has already been or is being uploaded</li>\r\n  <li>2008: Checksum mismatch</li>\r\n  <li>2009: Could not get data location url</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("2001: The requested attachment was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 502)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("2002: Error occurred during upload", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get information about the attachment and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AttachmentOverviewExt> AttachmentGETAsync(System.Guid attachmentId)
        {
            return AttachmentGETAsync(attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get information about the attachment and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AttachmentOverviewExt> AttachmentGETAsync(System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment/{attachmentId}"
                    urlBuilder_.Append("correspondence/api/v1/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentOverviewExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("2001: The requested attachment was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes the attachment
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns no data</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AttachmentOverviewExt> AttachmentDELETEAsync(System.Guid attachmentId)
        {
            return AttachmentDELETEAsync(attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes the attachment
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns no data</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AttachmentOverviewExt> AttachmentDELETEAsync(System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment/{attachmentId}"
                    urlBuilder_.Append("correspondence/api/v1/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentOverviewExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>2006: File has already been purged</li>\r\n  <li>2007: Attachment cannot be purged as it is linked to at least one existing correspondence</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("2001: The requested attachment was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get information about the attachment and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AttachmentDetailsExt> DetailsAsync(System.Guid attachmentId)
        {
            return DetailsAsync(attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get information about the attachment and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns attachment metadata</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AttachmentDetailsExt> DetailsAsync(System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment/{attachmentId}/details"
                    urlBuilder_.Append("correspondence/api/v1/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/details");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentDetailsExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("2001: The requested attachment was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads the attachment data
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns the attachment</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> DownloadAsync(System.Guid attachmentId)
        {
            return DownloadAsync(attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads the attachment data
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write
        /// </remarks>
        /// <returns>Returns the attachment</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> DownloadAsync(System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/attachment/{attachmentId}/download"
                    urlBuilder_.Append("correspondence/api/v1/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/download");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("2001: The requested attachment was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initialize Correspondences
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Requires uploads of specified attachments if any before it can be Published
        /// </remarks>
        /// <returns>Returns metadata about the initialized correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InitializeCorrespondencesResponseExt> CorrespondencePOSTAsync(InitializeCorrespondencesExt body)
        {
            return CorrespondencePOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initialize Correspondences
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Requires uploads of specified attachments if any before it can be Published
        /// </remarks>
        /// <returns>Returns metadata about the initialized correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InitializeCorrespondencesResponseExt> CorrespondencePOSTAsync(InitializeCorrespondencesExt body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence"
                    urlBuilder_.Append("correspondence/api/v1/correspondence");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InitializeCorrespondencesResponseExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1002: Message title must be plain text</li>\r\n  <li>1003: Message body must be markdown</li>\r\n  <li>1004: Message summary must be markdown</li>\r\n  <li>1006: Recipients must be unique</li>\r\n  <li>1007: Existing attachment not found</li>\r\n  <li>1008: DueDateTime cannot be prior to today</li>\r\n  <li>1009: DueDateTime cannot be prior to RequestedPublishTime</li>\r\n  <li>1010: AllowSystemDelete cannot be prior to today</li>\r\n  <li>1011: AllowSystemDelete cannot be prior to RequestedPublishTime</li>\r\n  <li>1012: AllowSystemDelete cannot be prior to DueDateTime</li>\r\n  <li>1013: Sender cannot delete correspondence that has been published</li>\r\n  <li>1016: DueDateTime is required when confirmation is needed</li>\r\n  <li>1017: The sender of the correspondence must be equal the sender of existing attachments</li>\r\n  <li>1018: Attachment is not published</li>\r\n  <li>1019: The Content field must be provided for the correspondence</li>\r\n  <li>1020: Message title cannot be empty</li>\r\n  <li>1021: Message body cannot be empty</li>\r\n  <li>1022: Message summary cannot be empty</li>\r\n  <li>1023: Invalid language chosen. Supported languages is Norsk bokm\u00e5l (nb), Nynorsk (nn) and English (en)</li>\r\n  <li>1033: The idempotency key must be a valid non-empty GUID</li>\r\n  <li>1035: Reply options must be well-formed URIs and HTTPS with a max length of 255 characters</li>\r\n  <li>3001: The requested notification template with the given language was not found</li>\r\n  <li>3002: Email body and subject must be provided when sending email notifications</li>\r\n  <li>3003: Reminder email body and subject must be provided when sending reminder email notifications</li>\r\n  <li>3004: SMS body must be provided when sending SMS notifications</li>\r\n  <li>3005: Reminder SMS body must be provided when sending reminder SMS notifications</li>\r\n  <li>3006: Email body, subject and SMS body must be provided when sending preferred notifications</li>\r\n  <li>3007: Reminder email body, subject and SMS body must be provided when sending reminder preferred notifications</li>\r\n  <li>3011: Invalid email provided for custom recipient</li>\r\n  <li>3012: Invalid mobile number provided. Mobile number can contain only \'+\' and numeric characters, and it must adhere to the E.164 standard</li>\r\n  <li>3015: Recipient overrides with email or mobile number are not allowed when using notification recipient name because of name lookup</li>\r\n  <li>3017: Custom recipient with multiple recipients is not allowed</li>\r\n  <li>3018: Custom recipient with multiple identifiers is not allowed</li>\r\n  <li>3019: Custom recipient without identifier is not allowed</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n  <li>4009: Resource type is not supported. Resource must be of type GenericAccessResource or CorrespondenceService</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>4008: Resource not whitelisted. Contact us on Slack or servicedesk@altinn.no</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1029: Could not find partyId for the following recipients: {recipients}</li>\r\n  <li>3001: The requested notification template with the given language was not found</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("<ul>\r\n  <li>1034: A correspondence with the same idempotent key already exists</li>\r\n</ul>", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1030: Recipient {recipientId} has reserved themselves from public correspondences. Can be overridden using the \'IgnoreReservation\' flag</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Gets a list of Correspondences for the authenticated user
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Meant for Receivers, but also available for Senders to track Correspondences
        /// </remarks>
        /// <param name="status">Represents the important statuses for an Correspondence</param>
        /// <returns>Returns a list of Correspondences</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CorrespondencesExt> CorrespondenceGETAsync(string resourceId, System.DateTimeOffset? from, System.DateTimeOffset? to, CorrespondenceStatusExt? status, CorrespondencesRoleType? role, string onBehalfOf, string sendersReference)
        {
            return CorrespondenceGETAsync(resourceId, from, to, status, role, onBehalfOf, sendersReference, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a list of Correspondences for the authenticated user
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Meant for Receivers, but also available for Senders to track Correspondences
        /// </remarks>
        /// <param name="status">Represents the important statuses for an Correspondence</param>
        /// <returns>Returns a list of Correspondences</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CorrespondencesExt> CorrespondenceGETAsync(string resourceId, System.DateTimeOffset? from, System.DateTimeOffset? to, CorrespondenceStatusExt? status, CorrespondencesRoleType? role, string onBehalfOf, string sendersReference, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence"
                    urlBuilder_.Append("correspondence/api/v1/correspondence");
                    urlBuilder_.Append('?');
                    if (resourceId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("resourceId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(resourceId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(from.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("to")).Append('=').Append(System.Uri.EscapeDataString(to.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (role != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("role")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(role, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (onBehalfOf != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("onBehalfOf")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(onBehalfOf, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sendersReference != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sendersReference")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sendersReference, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CorrespondencesExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1027: From date cannot be after to date</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization</li>\r\n  <li>4006: Could not determine the caller</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initialize Correspondences and uploads attachments in the same request
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Requires uploads of specified attachments if any before it can be Published
        /// </remarks>
        /// <param name="correspondence_ResourceId">The Resource Id associated with the correspondence service.</param>
        /// <param name="correspondence_Sender">The Sending organization of the correspondence.</param>
        /// <param name="correspondence_SendersReference">A reference used by senders and receivers to identify a specific Correspondence using external identification methods.</param>
        /// <param name="correspondence_MessageSender">An alternative name for the sender of the correspondence. The name will be displayed instead of the organization name.</param>
        /// <param name="correspondence_Content_Language">Gets or sets the language of the correspondence, specified according to ISO 639-1</param>
        /// <param name="correspondence_Content_MessageTitle">Gets or sets the correspondence message title. Subject.</param>
        /// <param name="correspondence_Content_MessageSummary">Gets or sets a summary text of the correspondence.</param>
        /// <param name="correspondence_Content_MessageBody">Gets or sets the main body of the correspondence.</param>
        /// <param name="correspondence_Content_Attachments">Gets or sets a list of attachments.</param>
        /// <param name="correspondence_RequestedPublishTime">When the correspondence should become visible to the recipient.</param>
        /// <param name="correspondence_AllowSystemDeleteAfter">When Altinn can remove the correspondence from its database.</param>
        /// <param name="correspondence_DueDateTime">When the recipient must reply to the correspondence</param>
        /// <param name="correspondence_ExternalReferences">A list of references Senders can use to tell the recipient that the correspondence is related to the referenced item(s)
        /// <br/>Examples include Altinn App instances, Altinn Broker File Transfers</param>
        /// <param name="correspondence_PropertyList">User-defined properties related to the Correspondence</param>
        /// <param name="correspondence_ReplyOptions">Options for how the recipient can reply to the Correspondence</param>
        /// <param name="correspondence_Notification_EmailSubject">The emails subject for the main notification</param>
        /// <param name="correspondence_Notification_EmailBody">The email body for the main notification</param>
        /// <param name="correspondence_Notification_SmsBody">The sms body for the main notification</param>
        /// <param name="correspondence_Notification_SendReminder">Should a reminder be sent if the notification is not confirmed or opened</param>
        /// <param name="correspondence_Notification_ReminderEmailSubject">The email subject to use for the reminder notification</param>
        /// <param name="correspondence_Notification_ReminderEmailBody">The email body to use for the reminder notification</param>
        /// <param name="correspondence_Notification_ReminderSmsBody">The sms body to use for the reminder notification</param>
        /// <param name="correspondence_Notification_SendersReference">Senders Reference for this notification</param>
        /// <param name="correspondence_Notification_RequestedSendTime">The date and time for when the notification should be sent.</param>
        /// <param name="correspondence_Notification_CustomRecipient_EmailAddress">the email address of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_MobileNumber">the mobileNumber of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_OrganizationNumber">the organization number of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_NationalIdentityNumber">The SSN of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_IsReserved">Boolean indicating if the recipient is reserved</param>
        /// <param name="correspondence_Notification_CustomNotificationRecipients">Only the first list of recipients will be used. If not set, the notification will be sent to the recipient of the Correspondence</param>
        /// <param name="correspondence_IgnoreReservation">Specifies whether the correspondence can override reservation against digital communication in KRR</param>
        /// <param name="correspondence_Published">Is null until the correspondence is published.</param>
        /// <param name="correspondence_IsConfirmationNeeded">Specifies whether reading the correspondence needs to be confirmed by the recipient</param>
        /// <param name="correspondence_IsConfidential">Specifies whether the correspondence is confidential</param>
        /// <param name="recipients">List of recipients for the correspondence, either as organization(urn:altinn:organization:identifier-no:ORGNR) or national identity number(urn:altinn:person:identifier-no:SSN)</param>
        /// <param name="existingAttachments">Existing attachments that should be added to the correspondence</param>
        /// <param name="idempotentKey">Optional idempotency key to prevent duplicate correspondence creation</param>
        /// <returns>Returns metadata about the initialized correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InitializeCorrespondencesResponseExt> Upload2Async(string correspondence_ResourceId, string correspondence_Sender, string correspondence_SendersReference, string correspondence_MessageSender, string correspondence_Content_Language, string correspondence_Content_MessageTitle, string correspondence_Content_MessageSummary, string correspondence_Content_MessageBody, System.Collections.Generic.IEnumerable<InitializeCorrespondenceAttachmentExt> correspondence_Content_Attachments, System.DateTimeOffset? correspondence_RequestedPublishTime, System.DateTimeOffset? correspondence_AllowSystemDeleteAfter, System.DateTimeOffset? correspondence_DueDateTime, System.Collections.Generic.IEnumerable<ExternalReferenceExt> correspondence_ExternalReferences, System.Collections.Generic.IDictionary<string, string> correspondence_PropertyList, System.Collections.Generic.IEnumerable<CorrespondenceReplyOptionExt> correspondence_ReplyOptions, NotificationTemplateExt? correspondence_Notification_NotificationTemplate, string correspondence_Notification_EmailSubject, string correspondence_Notification_EmailBody, EmailContentType? correspondence_Notification_EmailContentType, string correspondence_Notification_SmsBody, bool? correspondence_Notification_SendReminder, string correspondence_Notification_ReminderEmailSubject, string correspondence_Notification_ReminderEmailBody, EmailContentType? correspondence_Notification_ReminderEmailContentType, string correspondence_Notification_ReminderSmsBody, NotificationChannelExt? correspondence_Notification_NotificationChannel, NotificationChannelExt? correspondence_Notification_ReminderNotificationChannel, string correspondence_Notification_SendersReference, System.DateTimeOffset? correspondence_Notification_RequestedSendTime, string correspondence_Notification_CustomRecipient_EmailAddress, string correspondence_Notification_CustomRecipient_MobileNumber, string correspondence_Notification_CustomRecipient_OrganizationNumber, string correspondence_Notification_CustomRecipient_NationalIdentityNumber, bool? correspondence_Notification_CustomRecipient_IsReserved, System.Collections.Generic.IEnumerable<CustomNotificationRecipientExt> correspondence_Notification_CustomNotificationRecipients, bool? correspondence_IgnoreReservation, System.DateTimeOffset? correspondence_Published, bool? correspondence_IsConfirmationNeeded, bool? correspondence_IsConfidential, System.Collections.Generic.IEnumerable<string> recipients, System.Collections.Generic.IEnumerable<System.Guid> existingAttachments, System.Guid? idempotentKey, System.Collections.Generic.IEnumerable<FileParameter> attachments)
        {
            return Upload2Async(correspondence_ResourceId, correspondence_Sender, correspondence_SendersReference, correspondence_MessageSender, correspondence_Content_Language, correspondence_Content_MessageTitle, correspondence_Content_MessageSummary, correspondence_Content_MessageBody, correspondence_Content_Attachments, correspondence_RequestedPublishTime, correspondence_AllowSystemDeleteAfter, correspondence_DueDateTime, correspondence_ExternalReferences, correspondence_PropertyList, correspondence_ReplyOptions, correspondence_Notification_NotificationTemplate, correspondence_Notification_EmailSubject, correspondence_Notification_EmailBody, correspondence_Notification_EmailContentType, correspondence_Notification_SmsBody, correspondence_Notification_SendReminder, correspondence_Notification_ReminderEmailSubject, correspondence_Notification_ReminderEmailBody, correspondence_Notification_ReminderEmailContentType, correspondence_Notification_ReminderSmsBody, correspondence_Notification_NotificationChannel, correspondence_Notification_ReminderNotificationChannel, correspondence_Notification_SendersReference, correspondence_Notification_RequestedSendTime, correspondence_Notification_CustomRecipient_EmailAddress, correspondence_Notification_CustomRecipient_MobileNumber, correspondence_Notification_CustomRecipient_OrganizationNumber, correspondence_Notification_CustomRecipient_NationalIdentityNumber, correspondence_Notification_CustomRecipient_IsReserved, correspondence_Notification_CustomNotificationRecipients, correspondence_IgnoreReservation, correspondence_Published, correspondence_IsConfirmationNeeded, correspondence_IsConfidential, recipients, existingAttachments, idempotentKey, attachments, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initialize Correspondences and uploads attachments in the same request
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/>
        /// <br/>Requires uploads of specified attachments if any before it can be Published
        /// </remarks>
        /// <param name="correspondence_ResourceId">The Resource Id associated with the correspondence service.</param>
        /// <param name="correspondence_Sender">The Sending organization of the correspondence.</param>
        /// <param name="correspondence_SendersReference">A reference used by senders and receivers to identify a specific Correspondence using external identification methods.</param>
        /// <param name="correspondence_MessageSender">An alternative name for the sender of the correspondence. The name will be displayed instead of the organization name.</param>
        /// <param name="correspondence_Content_Language">Gets or sets the language of the correspondence, specified according to ISO 639-1</param>
        /// <param name="correspondence_Content_MessageTitle">Gets or sets the correspondence message title. Subject.</param>
        /// <param name="correspondence_Content_MessageSummary">Gets or sets a summary text of the correspondence.</param>
        /// <param name="correspondence_Content_MessageBody">Gets or sets the main body of the correspondence.</param>
        /// <param name="correspondence_Content_Attachments">Gets or sets a list of attachments.</param>
        /// <param name="correspondence_RequestedPublishTime">When the correspondence should become visible to the recipient.</param>
        /// <param name="correspondence_AllowSystemDeleteAfter">When Altinn can remove the correspondence from its database.</param>
        /// <param name="correspondence_DueDateTime">When the recipient must reply to the correspondence</param>
        /// <param name="correspondence_ExternalReferences">A list of references Senders can use to tell the recipient that the correspondence is related to the referenced item(s)
        /// <br/>Examples include Altinn App instances, Altinn Broker File Transfers</param>
        /// <param name="correspondence_PropertyList">User-defined properties related to the Correspondence</param>
        /// <param name="correspondence_ReplyOptions">Options for how the recipient can reply to the Correspondence</param>
        /// <param name="correspondence_Notification_EmailSubject">The emails subject for the main notification</param>
        /// <param name="correspondence_Notification_EmailBody">The email body for the main notification</param>
        /// <param name="correspondence_Notification_SmsBody">The sms body for the main notification</param>
        /// <param name="correspondence_Notification_SendReminder">Should a reminder be sent if the notification is not confirmed or opened</param>
        /// <param name="correspondence_Notification_ReminderEmailSubject">The email subject to use for the reminder notification</param>
        /// <param name="correspondence_Notification_ReminderEmailBody">The email body to use for the reminder notification</param>
        /// <param name="correspondence_Notification_ReminderSmsBody">The sms body to use for the reminder notification</param>
        /// <param name="correspondence_Notification_SendersReference">Senders Reference for this notification</param>
        /// <param name="correspondence_Notification_RequestedSendTime">The date and time for when the notification should be sent.</param>
        /// <param name="correspondence_Notification_CustomRecipient_EmailAddress">the email address of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_MobileNumber">the mobileNumber of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_OrganizationNumber">the organization number of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_NationalIdentityNumber">The SSN of the recipient</param>
        /// <param name="correspondence_Notification_CustomRecipient_IsReserved">Boolean indicating if the recipient is reserved</param>
        /// <param name="correspondence_Notification_CustomNotificationRecipients">Only the first list of recipients will be used. If not set, the notification will be sent to the recipient of the Correspondence</param>
        /// <param name="correspondence_IgnoreReservation">Specifies whether the correspondence can override reservation against digital communication in KRR</param>
        /// <param name="correspondence_Published">Is null until the correspondence is published.</param>
        /// <param name="correspondence_IsConfirmationNeeded">Specifies whether reading the correspondence needs to be confirmed by the recipient</param>
        /// <param name="correspondence_IsConfidential">Specifies whether the correspondence is confidential</param>
        /// <param name="recipients">List of recipients for the correspondence, either as organization(urn:altinn:organization:identifier-no:ORGNR) or national identity number(urn:altinn:person:identifier-no:SSN)</param>
        /// <param name="existingAttachments">Existing attachments that should be added to the correspondence</param>
        /// <param name="idempotentKey">Optional idempotency key to prevent duplicate correspondence creation</param>
        /// <returns>Returns metadata about the initialized correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InitializeCorrespondencesResponseExt> Upload2Async(string correspondence_ResourceId, string correspondence_Sender, string correspondence_SendersReference, string correspondence_MessageSender, string correspondence_Content_Language, string correspondence_Content_MessageTitle, string correspondence_Content_MessageSummary, string correspondence_Content_MessageBody, System.Collections.Generic.IEnumerable<InitializeCorrespondenceAttachmentExt> correspondence_Content_Attachments, System.DateTimeOffset? correspondence_RequestedPublishTime, System.DateTimeOffset? correspondence_AllowSystemDeleteAfter, System.DateTimeOffset? correspondence_DueDateTime, System.Collections.Generic.IEnumerable<ExternalReferenceExt> correspondence_ExternalReferences, System.Collections.Generic.IDictionary<string, string> correspondence_PropertyList, System.Collections.Generic.IEnumerable<CorrespondenceReplyOptionExt> correspondence_ReplyOptions, NotificationTemplateExt? correspondence_Notification_NotificationTemplate, string correspondence_Notification_EmailSubject, string correspondence_Notification_EmailBody, EmailContentType? correspondence_Notification_EmailContentType, string correspondence_Notification_SmsBody, bool? correspondence_Notification_SendReminder, string correspondence_Notification_ReminderEmailSubject, string correspondence_Notification_ReminderEmailBody, EmailContentType? correspondence_Notification_ReminderEmailContentType, string correspondence_Notification_ReminderSmsBody, NotificationChannelExt? correspondence_Notification_NotificationChannel, NotificationChannelExt? correspondence_Notification_ReminderNotificationChannel, string correspondence_Notification_SendersReference, System.DateTimeOffset? correspondence_Notification_RequestedSendTime, string correspondence_Notification_CustomRecipient_EmailAddress, string correspondence_Notification_CustomRecipient_MobileNumber, string correspondence_Notification_CustomRecipient_OrganizationNumber, string correspondence_Notification_CustomRecipient_NationalIdentityNumber, bool? correspondence_Notification_CustomRecipient_IsReserved, System.Collections.Generic.IEnumerable<CustomNotificationRecipientExt> correspondence_Notification_CustomNotificationRecipients, bool? correspondence_IgnoreReservation, System.DateTimeOffset? correspondence_Published, bool? correspondence_IsConfirmationNeeded, bool? correspondence_IsConfidential, System.Collections.Generic.IEnumerable<string> recipients, System.Collections.Generic.IEnumerable<System.Guid> existingAttachments, System.Guid? idempotentKey, System.Collections.Generic.IEnumerable<FileParameter> attachments, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

                    if (correspondence_ResourceId == null)
                        throw new System.ArgumentNullException("correspondence_ResourceId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_ResourceId, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.ResourceId");
                    }

                    if (correspondence_Sender == null)
                        throw new System.ArgumentNullException("correspondence_Sender");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Sender, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Sender");
                    }

                    if (correspondence_SendersReference == null)
                        throw new System.ArgumentNullException("correspondence_SendersReference");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_SendersReference, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.SendersReference");
                    }

                    if (correspondence_MessageSender == null)
                        throw new System.ArgumentNullException("correspondence_MessageSender");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_MessageSender, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.MessageSender");
                    }

                    if (correspondence_Content_Language == null)
                        throw new System.ArgumentNullException("correspondence_Content_Language");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Content_Language, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Content.Language");
                    }

                    if (correspondence_Content_MessageTitle == null)
                        throw new System.ArgumentNullException("correspondence_Content_MessageTitle");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Content_MessageTitle, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Content.MessageTitle");
                    }

                    if (correspondence_Content_MessageSummary == null)
                        throw new System.ArgumentNullException("correspondence_Content_MessageSummary");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Content_MessageSummary, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Content.MessageSummary");
                    }

                    if (correspondence_Content_MessageBody == null)
                        throw new System.ArgumentNullException("correspondence_Content_MessageBody");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Content_MessageBody, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Content.MessageBody");
                    }

                    if (correspondence_Content_Attachments == null)
                        throw new System.ArgumentNullException("correspondence_Content_Attachments");
                    else
                    {
                        foreach (var item_ in correspondence_Content_Attachments)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Content.Attachments");
                        }
                    }

                    if (correspondence_RequestedPublishTime == null)
                        throw new System.ArgumentNullException("correspondence_RequestedPublishTime");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_RequestedPublishTime, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.RequestedPublishTime");
                    }

                    if (correspondence_AllowSystemDeleteAfter == null)
                        throw new System.ArgumentNullException("correspondence_AllowSystemDeleteAfter");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_AllowSystemDeleteAfter, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.AllowSystemDeleteAfter");
                    }

                    if (correspondence_DueDateTime == null)
                        throw new System.ArgumentNullException("correspondence_DueDateTime");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_DueDateTime, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.DueDateTime");
                    }

                    if (correspondence_ExternalReferences == null)
                        throw new System.ArgumentNullException("correspondence_ExternalReferences");
                    else
                    {
                        foreach (var item_ in correspondence_ExternalReferences)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.ExternalReferences");
                        }
                    }

                    if (correspondence_PropertyList == null)
                        throw new System.ArgumentNullException("correspondence_PropertyList");
                    else
                    {
                        var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(correspondence_PropertyList, JsonSerializerSettings);
                        content_.Add(new System.Net.Http.ByteArrayContent(json_), "Correspondence.PropertyList");
                    }

                    if (correspondence_ReplyOptions == null)
                        throw new System.ArgumentNullException("correspondence_ReplyOptions");
                    else
                    {
                        foreach (var item_ in correspondence_ReplyOptions)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.ReplyOptions");
                        }
                    }

                    if (correspondence_Notification_NotificationTemplate == null)
                        throw new System.ArgumentNullException("correspondence_Notification_NotificationTemplate");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_NotificationTemplate, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.NotificationTemplate");
                    }

                    if (correspondence_Notification_EmailSubject == null)
                        throw new System.ArgumentNullException("correspondence_Notification_EmailSubject");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_EmailSubject, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.EmailSubject");
                    }

                    if (correspondence_Notification_EmailBody == null)
                        throw new System.ArgumentNullException("correspondence_Notification_EmailBody");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_EmailBody, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.EmailBody");
                    }

                    if (correspondence_Notification_EmailContentType == null)
                        throw new System.ArgumentNullException("correspondence_Notification_EmailContentType");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_EmailContentType, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.EmailContentType");
                    }

                    if (correspondence_Notification_SmsBody == null)
                        throw new System.ArgumentNullException("correspondence_Notification_SmsBody");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_SmsBody, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.SmsBody");
                    }

                    if (correspondence_Notification_SendReminder == null)
                        throw new System.ArgumentNullException("correspondence_Notification_SendReminder");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_SendReminder, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.SendReminder");
                    }

                    if (correspondence_Notification_ReminderEmailSubject == null)
                        throw new System.ArgumentNullException("correspondence_Notification_ReminderEmailSubject");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_ReminderEmailSubject, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.ReminderEmailSubject");
                    }

                    if (correspondence_Notification_ReminderEmailBody == null)
                        throw new System.ArgumentNullException("correspondence_Notification_ReminderEmailBody");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_ReminderEmailBody, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.ReminderEmailBody");
                    }

                    if (correspondence_Notification_ReminderEmailContentType == null)
                        throw new System.ArgumentNullException("correspondence_Notification_ReminderEmailContentType");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_ReminderEmailContentType, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.ReminderEmailContentType");
                    }

                    if (correspondence_Notification_ReminderSmsBody == null)
                        throw new System.ArgumentNullException("correspondence_Notification_ReminderSmsBody");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_ReminderSmsBody, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.ReminderSmsBody");
                    }

                    if (correspondence_Notification_NotificationChannel == null)
                        throw new System.ArgumentNullException("correspondence_Notification_NotificationChannel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_NotificationChannel, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.NotificationChannel");
                    }

                    if (correspondence_Notification_ReminderNotificationChannel == null)
                        throw new System.ArgumentNullException("correspondence_Notification_ReminderNotificationChannel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_ReminderNotificationChannel, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.ReminderNotificationChannel");
                    }

                    if (correspondence_Notification_SendersReference == null)
                        throw new System.ArgumentNullException("correspondence_Notification_SendersReference");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_SendersReference, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.SendersReference");
                    }

                    if (correspondence_Notification_RequestedSendTime == null)
                        throw new System.ArgumentNullException("correspondence_Notification_RequestedSendTime");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_RequestedSendTime, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.RequestedSendTime");
                    }

                    if (correspondence_Notification_CustomRecipient_EmailAddress == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomRecipient_EmailAddress");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_CustomRecipient_EmailAddress, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomRecipient.EmailAddress");
                    }

                    if (correspondence_Notification_CustomRecipient_MobileNumber == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomRecipient_MobileNumber");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_CustomRecipient_MobileNumber, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomRecipient.MobileNumber");
                    }

                    if (correspondence_Notification_CustomRecipient_OrganizationNumber == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomRecipient_OrganizationNumber");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_CustomRecipient_OrganizationNumber, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomRecipient.OrganizationNumber");
                    }

                    if (correspondence_Notification_CustomRecipient_NationalIdentityNumber == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomRecipient_NationalIdentityNumber");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_CustomRecipient_NationalIdentityNumber, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomRecipient.NationalIdentityNumber");
                    }

                    if (correspondence_Notification_CustomRecipient_IsReserved == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomRecipient_IsReserved");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Notification_CustomRecipient_IsReserved, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomRecipient.IsReserved");
                    }

                    if (correspondence_Notification_CustomNotificationRecipients == null)
                        throw new System.ArgumentNullException("correspondence_Notification_CustomNotificationRecipients");
                    else
                    {
                        foreach (var item_ in correspondence_Notification_CustomNotificationRecipients)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Notification.CustomNotificationRecipients");
                        }
                    }

                    if (correspondence_IgnoreReservation == null)
                        throw new System.ArgumentNullException("correspondence_IgnoreReservation");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_IgnoreReservation, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.IgnoreReservation");
                    }

                    if (correspondence_Published == null)
                        throw new System.ArgumentNullException("correspondence_Published");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_Published, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.Published");
                    }

                    if (correspondence_IsConfirmationNeeded == null)
                        throw new System.ArgumentNullException("correspondence_IsConfirmationNeeded");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_IsConfirmationNeeded, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.IsConfirmationNeeded");
                    }

                    if (correspondence_IsConfidential == null)
                        throw new System.ArgumentNullException("correspondence_IsConfidential");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(correspondence_IsConfidential, System.Globalization.CultureInfo.InvariantCulture)), "Correspondence.IsConfidential");
                    }

                    if (recipients == null)
                        throw new System.ArgumentNullException("recipients");
                    else
                    {
                        foreach (var item_ in recipients)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "Recipients");
                        }
                    }

                    if (existingAttachments == null)
                        throw new System.ArgumentNullException("existingAttachments");
                    else
                    {
                        foreach (var item_ in existingAttachments)
                        {
                            content_.Add(new System.Net.Http.StringContent(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture)), "ExistingAttachments");
                        }
                    }

                    if (idempotentKey == null)
                        throw new System.ArgumentNullException("idempotentKey");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(idempotentKey, System.Globalization.CultureInfo.InvariantCulture)), "IdempotentKey");
                    }

                    if (attachments == null)
                        throw new System.ArgumentNullException("attachments");
                    else
                    {
                        foreach (var item_ in attachments)
                        {
                            var content_attachments_ = new System.Net.Http.StreamContent(item_.Data);
                            if (!string.IsNullOrEmpty(item_.ContentType))
                                content_attachments_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(item_.ContentType);
                            content_.Add(content_attachments_, "attachments", item_.FileName ?? "attachments");
                        }
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/upload"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/upload");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InitializeCorrespondencesResponseExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1002: Message title must be plain text</li>\r\n  <li>1003: Message body must be markdown</li>\r\n  <li>1004: Message summary must be markdown</li>\r\n  <li>1005: Mismatch between uploaded files and attachment metadata</li>\r\n  <li>1006: Recipients must be unique</li>\r\n  <li>1007: Existing attachment not found</li>\r\n  <li>1008: DueDateTime cannot be prior to today</li>\r\n  <li>1009: DueDateTime cannot be prior to RequestedPublishTime</li>\r\n  <li>1010: AllowSystemDelete cannot be prior to today</li>\r\n  <li>1011: AllowSystemDelete cannot be prior to RequestedPublishTime</li>\r\n  <li>1012: AllowSystemDelete cannot be prior to DueDateTime</li>\r\n  <li>1013: Sender cannot delete correspondence that has been published</li>\r\n  <li>1016: DueDateTime is required when confirmation is needed</li>\r\n  <li>1017: The sender of the correspondence must be equal the sender of existing attachments</li>\r\n  <li>1018: Attachment is not published</li>\r\n  <li>1019: The Content field must be provided for the correspondence</li>\r\n  <li>1020: Message title cannot be empty</li>\r\n  <li>1021: Message body cannot be empty</li>\r\n  <li>1022: Message summary cannot be empty</li>\r\n  <li>1023: Invalid language chosen. Supported languages is Norsk bokm\u00e5l (nb), Nynorsk (nn) and English (en)</li>\r\n  <li>1033: The idempotency key must be a valid non-empty GUID</li>\r\n  <li>1035: Reply options must be well-formed URIs and HTTPS with a max length of 255 characters</li>\r\n  <li>2001: The requested attachment was not found</li>\r\n  <li>2004: File must have content and has a max file size of 250 MB</li>\r\n  <li>2008: Checksum mismatch</li>\r\n  <li>2009: Could not get data location url</li>\r\n  <li>2010: Filename is missing</li>\r\n  <li>2011: Filename is too long</li>\r\n  <li>2012: Filename contains invalid characters</li>\r\n  <li>2013: Filetype not allowed</li>\r\n  <li>3001: The requested notification template with the given language was not found</li>\r\n  <li>3002: Email body and subject must be provided when sending email notifications</li>\r\n  <li>3003: Reminder email body and subject must be provided when sending reminder email notifications</li>\r\n  <li>3004: SMS body must be provided when sending SMS notifications</li>\r\n  <li>3005: Reminder SMS body must be provided when sending reminder SMS notifications</li>\r\n  <li>3006: Email body, subject and SMS body must be provided when sending preferred notifications</li>\r\n  <li>3007: Reminder email body, subject and SMS body must be provided when sending reminder preferred notifications</li>\r\n  <li>3011: Invalid email provided for custom recipient</li>\r\n  <li>3012: Invalid mobile number provided. Mobile number can contain only \'+\' and numeric characters, and it must adhere to the E.164 standard</li>\r\n  <li>3015: Recipient overrides with email or mobile number are not allowed when using notification recipient name because of name lookup</li>\r\n  <li>3017: Custom recipient with multiple recipients is not allowed</li>\r\n  <li>3018: Custom recipient with multiple identifiers is not allowed</li>\r\n  <li>3019: Custom recipient without identifier is not allowed</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n  <li>4009: Resource type is not supported. Resource must be of type GenericAccessResource or CorrespondenceService</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>4008: Resource not whitelisted. Contact us on Slack or servicedesk@altinn.no</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1029: Could not find partyId for the following recipients: {recipients}</li>\r\n  <li>3001: The requested notification template with the given language was not found</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("<ul>\r\n  <li>1034: A correspondence with the same idempotent key already exists</li>\r\n</ul>", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1030: Recipient {recipientId} has reserved themselves from public correspondences. Can be overridden using the \'IgnoreReservation\' flag</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 502)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("<ul>\r\n  <li>2002: Error occurred during upload</li>\r\n</ul>", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get information about the Correspondence and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/> - altinn:correspondence.read 
        /// <br/>
        /// <br/> - altinn:correspondence.write 
        /// <br/>
        /// <br/>Mostly for use by recipients and occasional status checks
        /// </remarks>
        /// <returns>Returns an overview of metadata about the published correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CorrespondenceOverviewExt> CorrespondenceGET2Async(System.Guid correspondenceId)
        {
            return CorrespondenceGET2Async(correspondenceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get information about the Correspondence and its current status
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/> - altinn:correspondence.read 
        /// <br/>
        /// <br/> - altinn:correspondence.write 
        /// <br/>
        /// <br/>Mostly for use by recipients and occasional status checks
        /// </remarks>
        /// <returns>Returns an overview of metadata about the published correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CorrespondenceOverviewExt> CorrespondenceGET2Async(System.Guid correspondenceId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CorrespondenceOverviewExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4002: Could not retrieve party uuid from lookup in Altinn Register", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("1001: The requested correspondence was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get more detailed information about the Correspondence and its current status as well as noticiation statuses, if available
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/> - altinn:correspondence.read 
        /// <br/>
        /// <br/> - altinn:correspondence.write 
        /// <br/>
        /// <br/>Meant for Senders that want a complete overview of the status and history of the Correspondence, but also available for Receivers
        /// </remarks>
        /// <returns>Detailed information about the correspondence with current status and status history</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CorrespondenceDetailsExt> Details2Async(System.Guid correspondenceId)
        {
            return Details2Async(correspondenceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get more detailed information about the Correspondence and its current status as well as noticiation statuses, if available
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/> - altinn:correspondence.read 
        /// <br/>
        /// <br/> - altinn:correspondence.write 
        /// <br/>
        /// <br/>Meant for Senders that want a complete overview of the status and history of the Correspondence, but also available for Receivers
        /// </remarks>
        /// <returns>Detailed information about the correspondence with current status and status history</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CorrespondenceDetailsExt> Details2Async(System.Guid correspondenceId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}/details"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/details");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CorrespondenceDetailsExt>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4002: Could not retrieve party uuid from lookup in Altinn Register", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("1001: The requested correspondence was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Mark Correspondence found by ID as read
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Guid> MarkasreadAsync(System.Guid correspondenceId)
        {
            return MarkasreadAsync(correspondenceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Mark Correspondence found by ID as read
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> MarkasreadAsync(System.Guid correspondenceId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}/markasread"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/markasread");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4002: Could not retrieve party uuid from lookup in Altinn Register", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("1001: The requested correspondence was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Mark Correspondence found by ID as confirmed
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Guid> ConfirmAsync(System.Guid correspondenceId)
        {
            return ConfirmAsync(correspondenceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Mark Correspondence found by ID as confirmed
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> ConfirmAsync(System.Guid correspondenceId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}/confirm"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/confirm");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4002: Could not retrieve party uuid from lookup in Altinn Register", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("1001: The requested correspondence was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete Correspondence found by ID
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/> (Can only purge before the correspondence is published)
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Guid> PurgeAsync(System.Guid correspondenceId)
        {
            return PurgeAsync(correspondenceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete Correspondence found by ID
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read 
        /// <br/>
        /// <br/>- altinn:correspondence.write 
        /// <br/> (Can only purge before the correspondence is published)
        /// </remarks>
        /// <returns>the Id of the correspondence</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> PurgeAsync(System.Guid correspondenceId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}/purge"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/purge");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1013: Sender cannot delete correspondence that has been published</li>\r\n  <li>1014: Correspondence has already been purged</li>\r\n  <li>1015: Could not retrieve highest status for correspondence</li>\r\n  <li>1026: Cannot archive or delete a correspondence which has not been confirmed when confirmation is required</li>\r\n  <li>4002: Could not retrieve party uuid from lookup in Altinn Register</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("1001: The requested correspondence was not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads the attachment data
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>Returns the attachment file</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> Download2Async(System.Guid correspondenceId, System.Guid attachmentId)
        {
            return Download2Async(correspondenceId, attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads the attachment data
        /// </summary>
        /// <remarks>
        /// One of the scopes: 
        /// <br/>
        /// <br/>- altinn:correspondence.read
        /// </remarks>
        /// <returns>Returns the attachment file</returns>
        /// <exception cref="AltinnCorrespondenceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> Download2Async(System.Guid correspondenceId, System.Guid attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (correspondenceId == null)
                throw new System.ArgumentNullException("correspondenceId");

            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "correspondence/api/v1/correspondence/{correspondenceId}/attachment/{attachmentId}/download"
                    urlBuilder_.Append("correspondence/api/v1/correspondence/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(correspondenceId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attachment/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/download");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("4002: Could not retrieve party uuid from lookup in Altinn Register", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("4001: You must use an Altinn token, DialogToken or log in to IDPorten as someone with access to the resource and orgaization in Altinn Authorization", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AltinnCorrespondenceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AltinnCorrespondenceException<ProblemDetails>("<ul>\r\n  <li>1001: The requested correspondence was not found</li>\r\n  <li>2001: The requested attachment was not found</li>\r\n</ul>", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new AltinnCorrespondenceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new AltinnCorrespondenceException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new AltinnCorrespondenceException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Defines the location of the attachment data
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AttachmentDataLocationTypeExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AltinnCorrespondenceAttachment")]
        AltinnCorrespondenceAttachment = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ExternalStorage")]
        ExternalStorage = 1,

    }

    /// <summary>
    /// Represents an overview of a shared attachment that can be used by multiple correspondences
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttachmentDetailsExt
    {

        /// <summary>
        /// The name of the attachment file.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fileName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string FileName { get; set; }

        /// <summary>
        /// A logical name for the file, which will be shown in Altinn Inbox.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A value indicating whether the attachment is encrypted or not.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isEncrypted")]
        public bool IsEncrypted { get; set; }

        /// <summary>
        /// MD5 checksum for file data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// A reference value given to the attachment by the creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// Gets or sets the Resource Id for the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organisation of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Sender { get; set; }

        /// <summary>
        /// Unique Id for this attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("attachmentId")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid AttachmentId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AttachmentStatusExt Status { get; set; }

        /// <summary>
        /// Current attachment status text description
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Current Attachment Status was changed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StatusChanged { get; set; }

        /// <summary>
        /// List of correspondences that are using this attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondenceIds")]
        public System.Collections.Generic.ICollection<System.Guid> CorrespondenceIds { get; set; }

        /// <summary>
        /// The attachment data type in MIME format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dataType")]
        public string DataType { get; set; }

        /// <summary>
        /// The Status history for the Attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusHistory")]
        public System.Collections.Generic.ICollection<AttachmentStatusEvent> StatusHistory { get; set; }

    }

    /// <summary>
    /// Represents an overview of a shared attachment that can be used by multiple correspondences
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttachmentOverviewExt
    {

        /// <summary>
        /// The name of the attachment file.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fileName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string FileName { get; set; }

        /// <summary>
        /// A logical name for the file, which will be shown in Altinn Inbox.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A value indicating whether the attachment is encrypted or not.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isEncrypted")]
        public bool IsEncrypted { get; set; }

        /// <summary>
        /// MD5 checksum for file data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// A reference value given to the attachment by the creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// Gets or sets the Resource Id for the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organisation of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Sender { get; set; }

        /// <summary>
        /// Unique Id for this attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("attachmentId")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid AttachmentId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AttachmentStatusExt Status { get; set; }

        /// <summary>
        /// Current attachment status text description
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Current Attachment Status was changed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StatusChanged { get; set; }

        /// <summary>
        /// List of correspondences that are using this attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondenceIds")]
        public System.Collections.Generic.ICollection<System.Guid> CorrespondenceIds { get; set; }

        /// <summary>
        /// The attachment data type in MIME format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dataType")]
        public string DataType { get; set; }

    }

    /// <summary>
    /// An entity representing a Attachment Status Event
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttachmentStatusEvent
    {

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AttachmentStatusExt Status { get; set; }

        /// <summary>
        /// Attachment status text description
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Attachment Status occurred
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        public System.DateTimeOffset StatusChanged { get; set; }

    }

    /// <summary>
    /// Represents the important statuses for an attachment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AttachmentStatusExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Initialized")]
        Initialized = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"UploadProcessing")]
        UploadProcessing = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Published")]
        Published = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Purged")]
        Purged = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 4,

    }

    /// <summary>
    /// Represents a request object for the operation, InitializeCorrespondence, that can create a correspondence in Altinn.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BaseCorrespondenceExt
    {

        /// <summary>
        /// The Resource Id associated with the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organization of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.Obsolete]
        public string Sender { get; set; }

        /// <summary>
        /// A reference used by senders and receivers to identify a specific Correspondence using external identification methods.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// An alternative name for the sender of the correspondence. The name will be displayed instead of the organization name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageSender")]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string MessageSender { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public InitializeCorrespondenceContentExt Content { get; set; }

        /// <summary>
        /// When the correspondence should become visible to the recipient.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("requestedPublishTime")]
        public System.DateTimeOffset? RequestedPublishTime { get; set; }

        /// <summary>
        /// When Altinn can remove the correspondence from its database.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("allowSystemDeleteAfter")]
        public System.DateTimeOffset? AllowSystemDeleteAfter { get; set; }

        /// <summary>
        /// When the recipient must reply to the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dueDateTime")]
        public System.DateTimeOffset? DueDateTime { get; set; }

        /// <summary>
        /// A list of references Senders can use to tell the recipient that the correspondence is related to the referenced item(s)
        /// <br/>Examples include Altinn App instances, Altinn Broker File Transfers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("externalReferences")]
        public System.Collections.Generic.ICollection<ExternalReferenceExt> ExternalReferences { get; set; }

        /// <summary>
        /// User-defined properties related to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("propertyList")]
        public System.Collections.Generic.IDictionary<string, string> PropertyList { get; set; }

        /// <summary>
        /// Options for how the recipient can reply to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("replyOptions")]
        public System.Collections.Generic.ICollection<CorrespondenceReplyOptionExt> ReplyOptions { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notification")]
        public InitializeCorrespondenceNotificationExt Notification { get; set; }

        /// <summary>
        /// Specifies whether the correspondence can override reservation against digital communication in KRR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ignoreReservation")]
        public bool? IgnoreReservation { get; set; }

        /// <summary>
        /// Is null until the correspondence is published.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("published")]
        public System.DateTimeOffset? Published { get; set; }

        /// <summary>
        /// Specifies whether reading the correspondence needs to be confirmed by the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfirmationNeeded")]
        public bool IsConfirmationNeeded { get; set; }

        /// <summary>
        /// Specifies whether the correspondence is confidential
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfidential")]
        public bool IsConfidential { get; set; }

    }

    /// <summary>
    /// Represents a binary attachment to a Correspondence
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceAttachmentExt
    {

        /// <summary>
        /// The name of the attachment file.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fileName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string FileName { get; set; }

        /// <summary>
        /// A logical name for the file, which will be shown in Altinn Inbox.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A value indicating whether the attachment is encrypted or not.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isEncrypted")]
        public bool IsEncrypted { get; set; }

        /// <summary>
        /// MD5 checksum for file data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// A reference value given to the attachment by the creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// A unique id for the correspondence attachment.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public System.Guid Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("dataLocationType")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AttachmentDataLocationTypeExt DataLocationType { get; set; }

        /// <summary>
        /// The date on which this attachment is created
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created")]
        public System.DateTimeOffset Created { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AttachmentStatusExt Status { get; set; }

        /// <summary>
        /// Current attachment status text description
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Current Attachment Status was changed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        public System.DateTimeOffset StatusChanged { get; set; }

        /// <summary>
        /// When the attachment expires
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("expirationTime")]
        public System.DateTimeOffset ExpirationTime { get; set; }

        /// <summary>
        /// The attachment data type in MIME format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dataType")]
        public string DataType { get; set; }

    }

    /// <summary>
    /// Represents the content of a reportee element of the type correspondence.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceContentExt
    {

        /// <summary>
        /// Gets or sets the language of the correspondence, specified according to ISO 639-1
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("language")]
        public string Language { get; set; }

        /// <summary>
        /// Gets or sets the correspondence message title. Subject.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageTitle")]
        public string MessageTitle { get; set; }

        /// <summary>
        /// Gets or sets a summary text of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageSummary")]
        public string MessageSummary { get; set; }

        /// <summary>
        /// Gets or sets the main body of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageBody")]
        public string MessageBody { get; set; }

        /// <summary>
        /// Gets or sets a list of attachments.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("attachments")]
        public System.Collections.Generic.ICollection<CorrespondenceAttachmentExt> Attachments { get; set; }

    }

    /// <summary>
    /// A more detailed object representing all the details for a correspondence, including status history and notifications
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceDetailsExt
    {

        /// <summary>
        /// The Resource Id associated with the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organization of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.Obsolete]
        public string Sender { get; set; }

        /// <summary>
        /// A reference used by senders and receivers to identify a specific Correspondence using external identification methods.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// An alternative name for the sender of the correspondence. The name will be displayed instead of the organization name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageSender")]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string MessageSender { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public CorrespondenceContentExt Content { get; set; }

        /// <summary>
        /// When the correspondence should become visible to the recipient.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("requestedPublishTime")]
        public System.DateTimeOffset? RequestedPublishTime { get; set; }

        /// <summary>
        /// When Altinn can remove the correspondence from its database.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("allowSystemDeleteAfter")]
        public System.DateTimeOffset? AllowSystemDeleteAfter { get; set; }

        /// <summary>
        /// When the recipient must reply to the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dueDateTime")]
        public System.DateTimeOffset? DueDateTime { get; set; }

        /// <summary>
        /// A list of references Senders can use to tell the recipient that the correspondence is related to the referenced item(s)
        /// <br/>Examples include Altinn App instances, Altinn Broker File Transfers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("externalReferences")]
        public System.Collections.Generic.ICollection<ExternalReferenceExt> ExternalReferences { get; set; }

        /// <summary>
        /// User-defined properties related to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("propertyList")]
        public System.Collections.Generic.IDictionary<string, string> PropertyList { get; set; }

        /// <summary>
        /// Options for how the recipient can reply to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("replyOptions")]
        public System.Collections.Generic.ICollection<CorrespondenceReplyOptionExt> ReplyOptions { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notification")]
        public InitializeCorrespondenceNotificationExt Notification { get; set; }

        /// <summary>
        /// Specifies whether the correspondence can override reservation against digital communication in KRR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ignoreReservation")]
        public bool? IgnoreReservation { get; set; }

        /// <summary>
        /// Is null until the correspondence is published.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("published")]
        public System.DateTimeOffset? Published { get; set; }

        /// <summary>
        /// Specifies whether reading the correspondence needs to be confirmed by the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfirmationNeeded")]
        public bool IsConfirmationNeeded { get; set; }

        /// <summary>
        /// Specifies whether the correspondence is confidential
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfidential")]
        public bool IsConfidential { get; set; }

        /// <summary>
        /// The recipient of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipient")]
        public string Recipient { get; set; }

        /// <summary>
        /// Unique Id for this correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondenceId")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid CorrespondenceId { get; set; }

        /// <summary>
        /// When the correspondence was created
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CorrespondenceStatusExt Status { get; set; }

        /// <summary>
        /// The current status text for the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Current Correspondence Status was changed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        public System.DateTimeOffset StatusChanged { get; set; }

        /// <summary>
        /// Notifications directly related to this Correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notifications")]
        public System.Collections.Generic.ICollection<NotificationExt> Notifications { get; set; }

        /// <summary>
        /// The identifier/reference from Altinn 2 for migrated correspondence. Will be null for correspondence created in Altinn 3.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("altinn2CorrespondenceId")]
        public int? Altinn2CorrespondenceId { get; set; }

        /// <summary>
        /// The Status history for the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusHistory")]
        public System.Collections.Generic.ICollection<CorrespondenceStatusEventExt> StatusHistory { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceNotificationOverview
    {

        [System.Text.Json.Serialization.JsonPropertyName("notificationOrderId")]
        public System.Guid? NotificationOrderId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("isReminder")]
        public bool IsReminder { get; set; }

    }

    /// <summary>
    /// An object representing an overview of a correspondence with enough details to drive the business process
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceOverviewExt
    {

        /// <summary>
        /// The Resource Id associated with the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organization of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.Obsolete]
        public string Sender { get; set; }

        /// <summary>
        /// A reference used by senders and receivers to identify a specific Correspondence using external identification methods.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// An alternative name for the sender of the correspondence. The name will be displayed instead of the organization name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageSender")]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string MessageSender { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public CorrespondenceContentExt Content { get; set; }

        /// <summary>
        /// When the correspondence should become visible to the recipient.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("requestedPublishTime")]
        public System.DateTimeOffset? RequestedPublishTime { get; set; }

        /// <summary>
        /// When Altinn can remove the correspondence from its database.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("allowSystemDeleteAfter")]
        public System.DateTimeOffset? AllowSystemDeleteAfter { get; set; }

        /// <summary>
        /// When the recipient must reply to the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("dueDateTime")]
        public System.DateTimeOffset? DueDateTime { get; set; }

        /// <summary>
        /// A list of references Senders can use to tell the recipient that the correspondence is related to the referenced item(s)
        /// <br/>Examples include Altinn App instances, Altinn Broker File Transfers
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("externalReferences")]
        public System.Collections.Generic.ICollection<ExternalReferenceExt> ExternalReferences { get; set; }

        /// <summary>
        /// User-defined properties related to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("propertyList")]
        public System.Collections.Generic.IDictionary<string, string> PropertyList { get; set; }

        /// <summary>
        /// Options for how the recipient can reply to the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("replyOptions")]
        public System.Collections.Generic.ICollection<CorrespondenceReplyOptionExt> ReplyOptions { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notification")]
        public InitializeCorrespondenceNotificationExt Notification { get; set; }

        /// <summary>
        /// Specifies whether the correspondence can override reservation against digital communication in KRR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ignoreReservation")]
        public bool? IgnoreReservation { get; set; }

        /// <summary>
        /// Is null until the correspondence is published.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("published")]
        public System.DateTimeOffset? Published { get; set; }

        /// <summary>
        /// Specifies whether reading the correspondence needs to be confirmed by the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfirmationNeeded")]
        public bool IsConfirmationNeeded { get; set; }

        /// <summary>
        /// Specifies whether the correspondence is confidential
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isConfidential")]
        public bool IsConfidential { get; set; }

        /// <summary>
        /// The recipient of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipient")]
        public string Recipient { get; set; }

        /// <summary>
        /// Unique Id for this correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondenceId")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid CorrespondenceId { get; set; }

        /// <summary>
        /// When the correspondence was created
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CorrespondenceStatusExt Status { get; set; }

        /// <summary>
        /// The current status text for the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when the Current Correspondence Status was changed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        public System.DateTimeOffset StatusChanged { get; set; }

        /// <summary>
        /// An overview of the notifications for this correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notifications")]
        public System.Collections.Generic.ICollection<CorrespondenceNotificationOverview> Notifications { get; set; }

        /// <summary>
        /// The identifier/reference from Altinn 2 for migrated correspondence. Will be null for correspondence created in Altinn 3.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("altinn2CorrespondenceId")]
        public int? Altinn2CorrespondenceId { get; set; }

    }

    /// <summary>
    /// Represents a ReplyOption with information provided by the sender.
    /// <br/>A reply option is a way for recipients to respond to a correspondence in addition to the normal Read and Confirm operations
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceReplyOptionExt
    {

        /// <summary>
        /// Gets or sets the URL to be used as a reply/response to a correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("linkURL")]
        public string LinkURL { get; set; }

        /// <summary>
        /// Gets or sets the url text.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("linkText")]
        public string LinkText { get; set; }

    }

    /// <summary>
    /// An entity representing a Correspondence Status Event
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondenceStatusEventExt
    {

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CorrespondenceStatusExt Status { get; set; }

        /// <summary>
        /// Correspondence Status Text description
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusText")]
        public string StatusText { get; set; }

        /// <summary>
        /// Timestamp for when this Correspondence Status Event occurred
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("statusChanged")]
        public System.DateTimeOffset StatusChanged { get; set; }

    }

    /// <summary>
    /// Represents the important statuses for an Correspondence
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CorrespondenceStatusExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Initialized")]
        Initialized = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ReadyForPublish")]
        ReadyForPublish = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Published")]
        Published = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Fetched")]
        Fetched = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Read")]
        Read = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Replied")]
        Replied = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"Confirmed")]
        Confirmed = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PurgedByRecipient")]
        PurgedByRecipient = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"PurgedByAltinn")]
        PurgedByAltinn = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"Archived")]
        Archived = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"Reserved")]
        Reserved = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"AttachmentsDownloaded")]
        AttachmentsDownloaded = 12,

    }

    /// <summary>
    /// An entity representing a a list of Correspondences
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorrespondencesExt
    {

        /// <summary>
        /// Correspondence ids
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ids")]
        public System.Collections.Generic.ICollection<System.Guid> Ids { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CorrespondencesRoleType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Recipient")]
        Recipient = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Sender")]
        Sender = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RecipientAndSender")]
        RecipientAndSender = 2,

    }

    /// <summary>
    /// Represents a custom notification recipient with override options
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CustomNotificationRecipientExt
    {

        /// <summary>
        /// This is not used, but is required by the API.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipientToOverride")]
        public string RecipientToOverride { get; set; }

        /// <summary>
        /// Only the first recipient will be used as custom recipient.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipients")]
        public System.Collections.Generic.ICollection<NotificationRecipientExt> Recipients { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EmailContentType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Plain")]
        Plain = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Html")]
        Html = 1,

    }

    /// <summary>
    /// Represents a reference to another item in the Altinn ecosystem
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExternalReferenceExt
    {

        /// <summary>
        /// The Reference Value
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("referenceValue")]
        public string ReferenceValue { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("referenceType")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public ReferenceTypeExt ReferenceType { get; set; }

    }

    /// <summary>
    /// Defines the location of the attachment data during the Initialize Correspondence Operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InitializeAttachmentDataLocationTypeExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NewCorrespondenceAttachment")]
        NewCorrespondenceAttachment = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ExistingCorrespondenceAttachment")]
        ExistingCorrespondenceAttachment = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ExistingExternalStorage")]
        ExistingExternalStorage = 2,

    }

    /// <summary>
    /// Represents a container object for attachments used when initiating a shared attachment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeAttachmentExt
    {

        /// <summary>
        /// The name of the attachment file.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fileName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string FileName { get; set; }

        /// <summary>
        /// A logical name for the file, which will be shown in Altinn Inbox.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A value indicating whether the attachment is encrypted or not.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isEncrypted")]
        public bool IsEncrypted { get; set; }

        /// <summary>
        /// MD5 checksum for file data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// A reference value given to the attachment by the creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// Gets or sets the Resource Id for the correspondence service.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength = 1)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The Sending organisation of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sender")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Sender { get; set; }

    }

    /// <summary>
    /// Represents an attachment to a specific correspondence as part of Initialize Correspondence Operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeCorrespondenceAttachmentExt
    {

        /// <summary>
        /// The name of the attachment file.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fileName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string FileName { get; set; }

        /// <summary>
        /// A logical name for the file, which will be shown in Altinn Inbox.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A value indicating whether the attachment is encrypted or not.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isEncrypted")]
        public bool IsEncrypted { get; set; }

        /// <summary>
        /// MD5 checksum for file data.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("checksum")]
        public string Checksum { get; set; }

        /// <summary>
        /// A reference value given to the attachment by the creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(4096, MinimumLength = 1)]
        public string SendersReference { get; set; }

        /// <summary>
        /// A unique id for the correspondence attachment.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public System.Guid Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("dataLocationType")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public InitializeAttachmentDataLocationTypeExt DataLocationType { get; set; }

        /// <summary>
        /// The expiration time of the attachment
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("expirationTime")]
        public System.DateTimeOffset ExpirationTime { get; set; }

    }

    /// <summary>
    /// Represents the content of a Correspondence.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeCorrespondenceContentExt
    {

        /// <summary>
        /// Gets or sets the language of the correspondence, specified according to ISO 639-1
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("language")]
        public string Language { get; set; }

        /// <summary>
        /// Gets or sets the correspondence message title. Subject.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageTitle")]
        public string MessageTitle { get; set; }

        /// <summary>
        /// Gets or sets a summary text of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageSummary")]
        public string MessageSummary { get; set; }

        /// <summary>
        /// Gets or sets the main body of the correspondence.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("messageBody")]
        public string MessageBody { get; set; }

        /// <summary>
        /// Gets or sets a list of attachments.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("attachments")]
        public System.Collections.Generic.ICollection<InitializeCorrespondenceAttachmentExt> Attachments { get; set; }

    }

    /// <summary>
    /// Used to specify a single notification connected to a specific Correspondence during the Initialize Correspondence operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeCorrespondenceNotificationExt
    {

        [System.Text.Json.Serialization.JsonPropertyName("notificationTemplate")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NotificationTemplateExt NotificationTemplate { get; set; }

        /// <summary>
        /// The emails subject for the main notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("emailSubject")]
        [System.ComponentModel.DataAnnotations.StringLength(128)]
        public string EmailSubject { get; set; }

        /// <summary>
        /// The email body for the main notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("emailBody")]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string EmailBody { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("emailContentType")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EmailContentType EmailContentType { get; set; }

        /// <summary>
        /// The sms body for the main notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("smsBody")]
        [System.ComponentModel.DataAnnotations.StringLength(160)]
        public string SmsBody { get; set; }

        /// <summary>
        /// Should a reminder be sent if the notification is not confirmed or opened
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendReminder")]
        public bool SendReminder { get; set; }

        /// <summary>
        /// The email subject to use for the reminder notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("reminderEmailSubject")]
        [System.ComponentModel.DataAnnotations.StringLength(128)]
        public string ReminderEmailSubject { get; set; }

        /// <summary>
        /// The email body to use for the reminder notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("reminderEmailBody")]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string ReminderEmailBody { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("reminderEmailContentType")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EmailContentType ReminderEmailContentType { get; set; }

        /// <summary>
        /// The sms body to use for the reminder notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("reminderSmsBody")]
        [System.ComponentModel.DataAnnotations.StringLength(160)]
        public string ReminderSmsBody { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notificationChannel")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NotificationChannelExt NotificationChannel { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("reminderNotificationChannel")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NotificationChannelExt ReminderNotificationChannel { get; set; }

        /// <summary>
        /// Senders Reference for this notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        public string SendersReference { get; set; }

        /// <summary>
        /// The date and time for when the notification should be sent.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("requestedSendTime")]
        public System.DateTimeOffset? RequestedSendTime { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("customRecipient")]
        public NotificationRecipientExt CustomRecipient { get; set; }

        /// <summary>
        /// Only the first list of recipients will be used. If not set, the notification will be sent to the recipient of the Correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("customNotificationRecipients")]
        [System.Obsolete]
        public System.Collections.Generic.ICollection<CustomNotificationRecipientExt> CustomNotificationRecipients { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeCorrespondencesExt
    {

        [System.Text.Json.Serialization.JsonPropertyName("correspondence")]
        [System.ComponentModel.DataAnnotations.Required]
        public BaseCorrespondenceExt Correspondence { get; set; } = new BaseCorrespondenceExt();

        /// <summary>
        /// List of recipients for the correspondence, either as organization(urn:altinn:organization:identifier-no:ORGNR) or national identity number(urn:altinn:person:identifier-no:SSN)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipients")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Recipients { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Existing attachments that should be added to the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("existingAttachments")]
        public System.Collections.Generic.ICollection<System.Guid> ExistingAttachments { get; set; }

        /// <summary>
        /// Optional idempotency key to prevent duplicate correspondence creation
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("idempotentKey")]
        public System.Guid? IdempotentKey { get; set; }

    }

    /// <summary>
    /// Contains information about the created correspondences and their attachments.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializeCorrespondencesResponseExt
    {

        /// <summary>
        /// The initialized correspondences
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondences")]
        public System.Collections.Generic.ICollection<InitializedCorrespondencesExt> Correspondences { get; set; }

        /// <summary>
        /// The IDs of the attachments that is included in the correspondences
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("attachmentIds")]
        public System.Collections.Generic.ICollection<System.Guid> AttachmentIds { get; set; }

    }

    /// <summary>
    /// Represents a correspondence that has been initialized
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializedCorrespondencesExt
    {

        /// <summary>
        /// The ID of the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("correspondenceId")]
        public System.Guid CorrespondenceId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CorrespondenceStatusExt Status { get; set; }

        /// <summary>
        /// The recipient of the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipient")]
        public string Recipient { get; set; }

        /// <summary>
        /// Information about the notifications that were created for the correspondence
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notifications")]
        public System.Collections.Generic.ICollection<InitializedCorrespondencesNotificationsExt> Notifications { get; set; }

    }

    /// <summary>
    /// Information about a notification that were created for the correspondence
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitializedCorrespondencesNotificationsExt
    {

        /// <summary>
        /// The order ID of the notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("orderId")]
        public System.Guid? OrderId { get; set; }

        /// <summary>
        /// Boolean indicating if the notification is a reminder
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isReminder")]
        public bool? IsReminder { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public InitializedNotificationStatusExt Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InitializedNotificationStatusExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Success")]
        Success = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MissingContact")]
        MissingContact = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Failure")]
        Failure = 2,

    }

    /// <summary>
    /// Enum describing available notification channels.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NotificationChannelExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Email")]
        Email = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Sms")]
        Sms = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"EmailPreferred")]
        EmailPreferred = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"SmsPreferred")]
        SmsPreferred = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"EmailAndSms")]
        EmailAndSms = 4,

    }

    /// <summary>
    /// An abstract class representing a status overview of a notification channels
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationDetailsExt
    {

        /// <summary>
        /// The notification id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public System.Guid? Id { get; set; }

        /// <summary>
        /// Boolean indicating if the sending of the notification was successful
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("succeeded")]
        public bool Succeeded { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("recipient")]
        public NotificationRecipientExt Recipient { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("sendStatus")]
        public NotificationStatusExt SendStatus { get; set; }

    }

    /// <summary>
    /// Represents a notification connected to a specific correspondence
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationExt
    {

        /// <summary>
        /// The id of the notification order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// An optional senders reference of the notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sendersReference")]
        public string SendersReference { get; set; }

        /// <summary>
        /// The requested send time of the notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("requestedSendTime")]
        public System.DateTimeOffset RequestedSendTime { get; set; }

        /// <summary>
        /// The short name of the creator of the notification order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("creator")]
        public string Creator { get; set; }

        /// <summary>
        /// The date and time of when the notification order was created
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created")]
        public System.DateTimeOffset Created { get; set; }

        /// <summary>
        /// whether the notification is a reminder notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isReminder")]
        public bool IsReminder { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notificationChannel")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NotificationChannelExt NotificationChannel { get; set; }

        /// <summary>
        /// Whether notifications generated by this order should ignore KRR reservations
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ignoreReservation")]
        public bool? IgnoreReservation { get; set; }

        /// <summary>
        /// The id of the resource that the notification is related to
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("resourceId")]
        public string ResourceId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("processingStatus")]
        public NotificationProcessStatusExt ProcessingStatus { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notificationStatusDetails")]
        public NotificationStatusDetailsExt NotificationStatusDetails { get; set; }

    }

    /// <summary>
    /// An abstract class representing a status overview of a notification channels
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationProcessStatusExt
    {

        /// <summary>
        /// The actual status of the notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The description of the status
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The date time of when the status was last updated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lastUpdate")]
        public System.DateTimeOffset LastUpdate { get; set; }

    }

    /// <summary>
    /// A class representing a a recipient of a notification
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationRecipientExt
    {

        /// <summary>
        /// the email address of the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("emailAddress")]
        public string EmailAddress { get; set; }

        /// <summary>
        /// the mobileNumber of the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("mobileNumber")]
        public string MobileNumber { get; set; }

        /// <summary>
        /// the organization number of the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("organizationNumber")]
        public string OrganizationNumber { get; set; }

        /// <summary>
        /// The SSN of the recipient
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("nationalIdentityNumber")]
        public string NationalIdentityNumber { get; set; }

        /// <summary>
        /// Boolean indicating if the recipient is reserved
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isReserved")]
        public bool? IsReserved { get; set; }

    }

    /// <summary>
    /// A class representing a summary of status overviews of all notification channels
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationStatusDetailsExt
    {

        [System.Text.Json.Serialization.JsonPropertyName("email")]
        public NotificationDetailsExt Email { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("sms")]
        public NotificationDetailsExt Sms { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("emails")]
        public System.Collections.Generic.ICollection<NotificationDetailsExt> Emails { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("smses")]
        public System.Collections.Generic.ICollection<NotificationDetailsExt> Smses { get; set; }

    }

    /// <summary>
    /// A class representing a status summary
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NotificationStatusExt
    {

        /// <summary>
        /// The actual status of the notification
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The description of the status
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The date time of when the status was last updated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lastUpdate")]
        public System.DateTimeOffset LastUpdate { get; set; }

    }

    /// <summary>
    /// Enum describing available notification templates.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NotificationTemplateExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CustomMessage")]
        CustomMessage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"GenericAltinnMessage")]
        GenericAltinnMessage = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProblemDetails
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("title")]
        public string Title { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public int? Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("detail")]
        public string Detail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("instance")]
        public string Instance { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Defines what kind of reference
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ReferenceTypeExt
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Generic")]
        Generic = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AltinnAppInstance")]
        AltinnAppInstance = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"AltinnBrokerFileTransfer")]
        AltinnBrokerFileTransfer = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"DialogportenDialogId")]
        DialogportenDialogId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"DialogportenProcessId")]
        DialogportenProcessId = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AltinnCorrespondenceException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public AltinnCorrespondenceException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AltinnCorrespondenceException<TResult> : AltinnCorrespondenceException
    {
        public TResult Result { get; private set; }

        public AltinnCorrespondenceException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765